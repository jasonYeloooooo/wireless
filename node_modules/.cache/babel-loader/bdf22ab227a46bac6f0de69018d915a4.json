{"ast":null,"code":"import { useMemo, useCallback } from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n};\n\nvar makeTickMarks = function makeTickMarks(minAngle, maxAngle, numTicks) {\n  var tickMarks = [];\n  var angleRange = maxAngle - minAngle;\n  var angleStep = angleRange / (numTicks - 1);\n\n  for (var i = 0; i < numTicks; i++) {\n    tickMarks.push(Math.floor(minAngle + i * angleStep));\n  }\n\n  return tickMarks.reverse();\n};\n\nvar polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  var angleInRadians = degreesToRadians(angleInDegrees);\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians)\n  };\n};\n\nvar _excluded = [\"offset\", \"startAngle\", \"endAngle\"];\n\nfunction useGauge(params) {\n  var startAngle = params.startAngle,\n      endAngle = params.endAngle,\n      numTicks = params.numTicks,\n      diameter = params.diameter,\n      domain = params.domain;\n  var radius = diameter / 2;\n  var minValue = domain[0],\n      maxValue = domain[1];\n  var ticks = useMemo(function () {\n    return makeTickMarks(startAngle, endAngle, numTicks).reverse();\n  }, [startAngle, endAngle, numTicks]);\n  var getLabelProps = useCallback(function (params) {\n    var angle = params.angle,\n        offset = params.offset;\n    var p1 = polarToCartesian(0, 0, radius - offset, angle + 90);\n    return {\n      x: p1.x,\n      y: p1.y,\n      dominantBaseline: 'middle',\n      textAnchor: 'middle'\n    };\n  }, [diameter, radius]);\n  var getTickProps = useCallback(function (params) {\n    var length = params.length,\n        angle = params.angle;\n    var p1 = polarToCartesian(0, 0, radius, angle + 90);\n    var p2 = polarToCartesian(0, 0, radius + length, angle + 90);\n    return {\n      key: \"tick-\" + angle,\n      x1: p1.x,\n      x2: p2.x,\n      y1: p1.y,\n      y2: p2.y\n    };\n  }, [ticks, diameter, radius]);\n\n  var angleToValue = function angleToValue(angle) {\n    var angleRange = endAngle - startAngle;\n    var valueRange = maxValue - minValue;\n    var value = minValue + (angle - startAngle) / angleRange * valueRange;\n    return Math.round(value);\n  };\n\n  var valueToAngle = function valueToAngle(value) {\n    var angleRange = endAngle - startAngle;\n    var valueRange = maxValue - minValue;\n    var angle = startAngle + (value - minValue) / valueRange * angleRange;\n    return Math.round(angle);\n  };\n\n  var getArcProps = useCallback(function (params) {\n    var _params$offset = params.offset,\n        offset = _params$offset === void 0 ? 0 : _params$offset,\n        startAngle = params.startAngle,\n        endAngle = params.endAngle,\n        rest = _objectWithoutPropertiesLoose(params, _excluded);\n\n    var start = polarToCartesian(0, 0, radius + offset, startAngle + 90);\n    var end = polarToCartesian(0, 0, radius + offset, endAngle + 90);\n    var largeArcFlag = endAngle - startAngle < 180 ? '0' : '1';\n    var d = ['M', start.x - 0.001, start.y, 'A', radius + offset, radius + offset, 0, largeArcFlag, 1, end.x, end.y].join(' ');\n    return _extends({\n      d: d\n    }, rest);\n  }, [diameter, radius]);\n  var getNeedleProps = useCallback(function (params) {\n    var value = params.value,\n        baseRadius = params.baseRadius,\n        tipRadius = params.tipRadius;\n    var angle = valueToAngle(value);\n    var baseCircleCenter = {\n      x: 0,\n      y: 0\n    };\n    var tipCircleCenter = polarToCartesian(0, 0, radius, angle + 90);\n    return {\n      base: {\n        r: baseRadius,\n        cx: baseCircleCenter.x,\n        cy: baseCircleCenter.y\n      },\n      tip: {\n        r: tipRadius,\n        cx: tipCircleCenter.x,\n        cy: tipCircleCenter.y\n      },\n      points: [[baseCircleCenter.x + baseRadius * Math.cos(degreesToRadians(angle)), baseCircleCenter.y + baseRadius * Math.sin(degreesToRadians(angle))], [tipCircleCenter.x + tipRadius * Math.cos(degreesToRadians(angle)), tipCircleCenter.y + tipRadius * Math.sin(degreesToRadians(angle))], [tipCircleCenter.x + tipRadius * Math.cos(degreesToRadians(angle - 180)), tipCircleCenter.y + tipRadius * Math.sin(degreesToRadians(angle - 180))], [baseCircleCenter.x + baseRadius * Math.cos(degreesToRadians(angle - 180)), baseCircleCenter.y + baseRadius * Math.sin(degreesToRadians(angle - 180))]].map(function (_ref) {\n        var x = _ref[0],\n            y = _ref[1];\n        return x + \",\" + y;\n      }).join(' ')\n    };\n  }, [valueToAngle, diameter, radius]);\n  var calculatediameterForDirection = useCallback(function (startAngle, deg) {\n    var angle = startAngle - deg;\n    var distance = Math.cos(degreesToRadians(angle)) * diameter / 2;\n    return distance;\n  }, [diameter]);\n\n  var getSVGProps = function getSVGProps() {\n    var getDistanceForDirection = function getDistanceForDirection(deg) {\n      if (startAngle < deg && endAngle > deg) return diameter / 2;\n      var startAngleDistance = calculatediameterForDirection(startAngle + 90, deg + 90);\n      var endAngleDistance = calculatediameterForDirection(endAngle + 90, deg + 90);\n      return Math.max(0, startAngleDistance, endAngleDistance);\n    };\n\n    var _ref2 = [getDistanceForDirection(180), getDistanceForDirection(270), getDistanceForDirection(0), getDistanceForDirection(90)],\n        top = _ref2[0],\n        right = _ref2[1],\n        bottom = _ref2[2],\n        left = _ref2[3];\n    var width = left + right;\n    var height = top + bottom;\n    var viewBox = [-left, -top, width, height].join(' ');\n    return {\n      width: width,\n      height: height,\n      viewBox: viewBox\n    };\n  };\n\n  return {\n    ticks: ticks,\n    getTickProps: getTickProps,\n    getLabelProps: getLabelProps,\n    valueToAngle: valueToAngle,\n    angleToValue: angleToValue,\n    getArcProps: getArcProps,\n    getNeedleProps: getNeedleProps,\n    getSVGProps: getSVGProps\n  };\n}\n\nexport { useGauge };","map":{"version":3,"mappings":"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","names":["degreesToRadians","degrees","Math","PI","makeTickMarks","minAngle","maxAngle","numTicks","tickMarks","angleRange","angleStep","i","push","floor","reverse","polarToCartesian","centerX","centerY","radius","angleInDegrees","angleInRadians","x","cos","y","sin","useGauge","params","startAngle","endAngle","diameter","domain","minValue","maxValue","ticks","useMemo","getLabelProps","useCallback","angle","offset","p1","dominantBaseline","textAnchor","getTickProps","length","p2","key","x1","x2","y1","y2","angleToValue","valueRange","value","round","valueToAngle","getArcProps","rest","start","end","largeArcFlag","d","join","getNeedleProps","baseRadius","tipRadius","baseCircleCenter","tipCircleCenter","base","r","cx","cy","tip","points","map","calculatediameterForDirection","deg","distance","getSVGProps","getDistanceForDirection","startAngleDistance","endAngleDistance","max","top","right","bottom","left","width","height","viewBox"],"sources":["/Users/jasonyellow/Desktop/project/WN_APP/wn_app/node_modules/use-gauge/src/lib.ts","/Users/jasonyellow/Desktop/project/WN_APP/wn_app/node_modules/use-gauge/src/index.tsx"],"sourcesContent":["export const degreesToRadians = (degrees: number) => {\n  return (degrees * Math.PI) / 180;\n};\n\nexport const makeTickMarks = (\n  minAngle: number,\n  maxAngle: number,\n  numTicks: number\n) => {\n  const tickMarks = [];\n  const angleRange = maxAngle - minAngle;\n  const angleStep = angleRange / (numTicks - 1);\n  for (let i = 0; i < numTicks; i++) {\n    tickMarks.push(Math.floor(minAngle + i * angleStep));\n  }\n  return tickMarks.reverse();\n};\n\nexport const polarToCartesian = (\n  centerX: number,\n  centerY: number,\n  radius: number,\n  angleInDegrees: number\n) => {\n  const angleInRadians = degreesToRadians(angleInDegrees);\n\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians),\n  };\n};\n","import { useCallback, useMemo } from 'react';\nimport { degreesToRadians, makeTickMarks, polarToCartesian } from './lib';\n\ninterface UseGaugeParams {\n  diameter: number;\n  startAngle: number;\n  endAngle: number;\n  numTicks: number;\n  domain: [number, number];\n}\n\ninterface GetNeedleParams {\n  value: number;\n  baseRadius: number;\n  tipRadius: number;\n}\n\ninterface GetTickPropsParams {\n  length: number;\n  angle: number;\n}\n\ninterface GetLabelPropsParams {\n  angle: number;\n  offset: number;\n}\n\ninterface GetArcPropsParams {\n  offset?: number;\n  startAngle: number;\n  endAngle: number;\n}\n\nexport function useGauge(params: UseGaugeParams) {\n  const { startAngle, endAngle, numTicks, diameter, domain } = params;\n  const radius = diameter / 2;\n  const [minValue, maxValue] = domain;\n\n  const ticks = useMemo(() => {\n    return makeTickMarks(startAngle, endAngle, numTicks).reverse();\n  }, [startAngle, endAngle, numTicks]);\n\n  const getLabelProps = useCallback(\n    (params: GetLabelPropsParams) => {\n      const { angle, offset } = params;\n      const p1 = polarToCartesian(0, 0, radius - offset, angle + 90);\n\n      return {\n        x: p1.x,\n        y: p1.y,\n        dominantBaseline: 'middle',\n        textAnchor: 'middle',\n      };\n    },\n    [diameter, radius]\n  );\n\n  const getTickProps = useCallback(\n    (params: GetTickPropsParams) => {\n      const { length, angle } = params;\n      const p1 = polarToCartesian(0, 0, radius, angle + 90);\n      const p2 = polarToCartesian(0, 0, radius + length, angle + 90);\n\n      return {\n        key: `tick-${angle}`,\n        x1: p1.x,\n        x2: p2.x,\n        y1: p1.y,\n        y2: p2.y,\n      };\n    },\n    [ticks, diameter, radius]\n  );\n\n  const angleToValue = (angle: number) => {\n    const angleRange = endAngle - startAngle;\n    const valueRange = maxValue - minValue;\n    const value = minValue + ((angle - startAngle) / angleRange) * valueRange;\n    return Math.round(value);\n  };\n\n  const valueToAngle = (value: number) => {\n    const angleRange = endAngle - startAngle;\n    const valueRange = maxValue - minValue;\n    const angle = startAngle + ((value - minValue) / valueRange) * angleRange;\n    return Math.round(angle);\n  };\n\n  const getArcProps = useCallback(\n    (params: GetArcPropsParams) => {\n      const { offset = 0, startAngle, endAngle, ...rest } = params;\n\n      let start = polarToCartesian(0, 0, radius + offset, startAngle + 90);\n      let end = polarToCartesian(0, 0, radius + offset, endAngle + 90);\n\n      let largeArcFlag = endAngle - startAngle < 180 ? '0' : '1';\n\n      let d = [\n        'M',\n        start.x - 0.001,\n        start.y,\n        'A',\n        radius + offset,\n        radius + offset,\n        0,\n        largeArcFlag,\n        1,\n        end.x,\n        end.y,\n      ].join(' ');\n\n      return {\n        d,\n        ...rest,\n      };\n    },\n    [diameter, radius]\n  );\n\n  const getNeedleProps = useCallback(\n    (params: GetNeedleParams) => {\n      const { value, baseRadius, tipRadius } = params;\n      const angle = valueToAngle(value);\n\n      const baseCircleCenter = {\n        x: 0,\n        y: 0,\n      };\n\n      const tipCircleCenter = polarToCartesian(0, 0, radius, angle + 90);\n\n      return {\n        base: {\n          r: baseRadius,\n          cx: baseCircleCenter.x,\n          cy: baseCircleCenter.y,\n        },\n        tip: {\n          r: tipRadius,\n          cx: tipCircleCenter.x,\n          cy: tipCircleCenter.y,\n        },\n        points: [\n          [\n            baseCircleCenter.x + baseRadius * Math.cos(degreesToRadians(angle)),\n            baseCircleCenter.y + baseRadius * Math.sin(degreesToRadians(angle)),\n          ],\n          [\n            tipCircleCenter.x + tipRadius * Math.cos(degreesToRadians(angle)),\n            tipCircleCenter.y + tipRadius * Math.sin(degreesToRadians(angle)),\n          ],\n          [\n            tipCircleCenter.x +\n              tipRadius * Math.cos(degreesToRadians(angle - 180)),\n            tipCircleCenter.y +\n              tipRadius * Math.sin(degreesToRadians(angle - 180)),\n          ],\n          [\n            baseCircleCenter.x +\n              baseRadius * Math.cos(degreesToRadians(angle - 180)),\n            baseCircleCenter.y +\n              baseRadius * Math.sin(degreesToRadians(angle - 180)),\n          ],\n        ]\n          .map(([x, y]) => `${x},${y}`)\n          .join(' '),\n      };\n    },\n    [valueToAngle, diameter, radius]\n  );\n\n  const calculatediameterForDirection = useCallback(\n    (startAngle: number, deg: number) => {\n      const angle = startAngle - deg;\n      const distance = (Math.cos(degreesToRadians(angle)) * diameter) / 2;\n      return distance;\n    },\n    [diameter]\n  );\n\n  const getSVGProps = () => {\n    const getDistanceForDirection = (deg: number) => {\n      if (startAngle < deg && endAngle > deg) return diameter / 2;\n      const startAngleDistance = calculatediameterForDirection(\n        startAngle + 90,\n        deg + 90\n      );\n      const endAngleDistance = calculatediameterForDirection(\n        endAngle + 90,\n        deg + 90\n      );\n      return Math.max(0, startAngleDistance, endAngleDistance);\n    };\n\n    const [top, right, bottom, left] = [\n      getDistanceForDirection(180),\n      getDistanceForDirection(270),\n      getDistanceForDirection(0),\n      getDistanceForDirection(90),\n    ];\n\n    const width = left + right;\n    const height = top + bottom;\n\n    const viewBox = [-left, -top, width, height].join(' ');\n\n    return {\n      width,\n      height,\n      viewBox,\n    };\n  };\n\n  return {\n    ticks,\n    getTickProps,\n    getLabelProps,\n    valueToAngle,\n    angleToValue,\n    getArcProps,\n    getNeedleProps,\n    getSVGProps,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}