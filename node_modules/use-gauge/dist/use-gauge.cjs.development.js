'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var degreesToRadians = function degreesToRadians(degrees) {
  return degrees * Math.PI / 180;
};
var makeTickMarks = function makeTickMarks(minAngle, maxAngle, numTicks) {
  var tickMarks = [];
  var angleRange = maxAngle - minAngle;
  var angleStep = angleRange / (numTicks - 1);

  for (var i = 0; i < numTicks; i++) {
    tickMarks.push(Math.floor(minAngle + i * angleStep));
  }

  return tickMarks.reverse();
};
var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
  var angleInRadians = degreesToRadians(angleInDegrees);
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
};

var _excluded = ["offset", "startAngle", "endAngle"];
function useGauge(params) {
  var startAngle = params.startAngle,
      endAngle = params.endAngle,
      numTicks = params.numTicks,
      diameter = params.diameter,
      domain = params.domain;
  var radius = diameter / 2;
  var minValue = domain[0],
      maxValue = domain[1];
  var ticks = react.useMemo(function () {
    return makeTickMarks(startAngle, endAngle, numTicks).reverse();
  }, [startAngle, endAngle, numTicks]);
  var getLabelProps = react.useCallback(function (params) {
    var angle = params.angle,
        offset = params.offset;
    var p1 = polarToCartesian(0, 0, radius - offset, angle + 90);
    return {
      x: p1.x,
      y: p1.y,
      dominantBaseline: 'middle',
      textAnchor: 'middle'
    };
  }, [diameter, radius]);
  var getTickProps = react.useCallback(function (params) {
    var length = params.length,
        angle = params.angle;
    var p1 = polarToCartesian(0, 0, radius, angle + 90);
    var p2 = polarToCartesian(0, 0, radius + length, angle + 90);
    return {
      key: "tick-" + angle,
      x1: p1.x,
      x2: p2.x,
      y1: p1.y,
      y2: p2.y
    };
  }, [ticks, diameter, radius]);

  var angleToValue = function angleToValue(angle) {
    var angleRange = endAngle - startAngle;
    var valueRange = maxValue - minValue;
    var value = minValue + (angle - startAngle) / angleRange * valueRange;
    return Math.round(value);
  };

  var valueToAngle = function valueToAngle(value) {
    var angleRange = endAngle - startAngle;
    var valueRange = maxValue - minValue;
    var angle = startAngle + (value - minValue) / valueRange * angleRange;
    return Math.round(angle);
  };

  var getArcProps = react.useCallback(function (params) {
    var _params$offset = params.offset,
        offset = _params$offset === void 0 ? 0 : _params$offset,
        startAngle = params.startAngle,
        endAngle = params.endAngle,
        rest = _objectWithoutPropertiesLoose(params, _excluded);

    var start = polarToCartesian(0, 0, radius + offset, startAngle + 90);
    var end = polarToCartesian(0, 0, radius + offset, endAngle + 90);
    var largeArcFlag = endAngle - startAngle < 180 ? '0' : '1';
    var d = ['M', start.x - 0.001, start.y, 'A', radius + offset, radius + offset, 0, largeArcFlag, 1, end.x, end.y].join(' ');
    return _extends({
      d: d
    }, rest);
  }, [diameter, radius]);
  var getNeedleProps = react.useCallback(function (params) {
    var value = params.value,
        baseRadius = params.baseRadius,
        tipRadius = params.tipRadius;
    var angle = valueToAngle(value);
    var baseCircleCenter = {
      x: 0,
      y: 0
    };
    var tipCircleCenter = polarToCartesian(0, 0, radius, angle + 90);
    return {
      base: {
        r: baseRadius,
        cx: baseCircleCenter.x,
        cy: baseCircleCenter.y
      },
      tip: {
        r: tipRadius,
        cx: tipCircleCenter.x,
        cy: tipCircleCenter.y
      },
      points: [[baseCircleCenter.x + baseRadius * Math.cos(degreesToRadians(angle)), baseCircleCenter.y + baseRadius * Math.sin(degreesToRadians(angle))], [tipCircleCenter.x + tipRadius * Math.cos(degreesToRadians(angle)), tipCircleCenter.y + tipRadius * Math.sin(degreesToRadians(angle))], [tipCircleCenter.x + tipRadius * Math.cos(degreesToRadians(angle - 180)), tipCircleCenter.y + tipRadius * Math.sin(degreesToRadians(angle - 180))], [baseCircleCenter.x + baseRadius * Math.cos(degreesToRadians(angle - 180)), baseCircleCenter.y + baseRadius * Math.sin(degreesToRadians(angle - 180))]].map(function (_ref) {
        var x = _ref[0],
            y = _ref[1];
        return x + "," + y;
      }).join(' ')
    };
  }, [valueToAngle, diameter, radius]);
  var calculatediameterForDirection = react.useCallback(function (startAngle, deg) {
    var angle = startAngle - deg;
    var distance = Math.cos(degreesToRadians(angle)) * diameter / 2;
    return distance;
  }, [diameter]);

  var getSVGProps = function getSVGProps() {
    var getDistanceForDirection = function getDistanceForDirection(deg) {
      if (startAngle < deg && endAngle > deg) return diameter / 2;
      var startAngleDistance = calculatediameterForDirection(startAngle + 90, deg + 90);
      var endAngleDistance = calculatediameterForDirection(endAngle + 90, deg + 90);
      return Math.max(0, startAngleDistance, endAngleDistance);
    };

    var _ref2 = [getDistanceForDirection(180), getDistanceForDirection(270), getDistanceForDirection(0), getDistanceForDirection(90)],
        top = _ref2[0],
        right = _ref2[1],
        bottom = _ref2[2],
        left = _ref2[3];
    var width = left + right;
    var height = top + bottom;
    var viewBox = [-left, -top, width, height].join(' ');
    return {
      width: width,
      height: height,
      viewBox: viewBox
    };
  };

  return {
    ticks: ticks,
    getTickProps: getTickProps,
    getLabelProps: getLabelProps,
    valueToAngle: valueToAngle,
    angleToValue: angleToValue,
    getArcProps: getArcProps,
    getNeedleProps: getNeedleProps,
    getSVGProps: getSVGProps
  };
}

exports.useGauge = useGauge;
//# sourceMappingURL=use-gauge.cjs.development.js.map
